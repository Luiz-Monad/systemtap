# Implicit Thread Local Storage tapset
# Copyright (C) 2020 Red Hat, Inc.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
# Reference: "ELF Handling For Thread-Local Storage" by Ulrich Drepper

global tls_debug = 0
private global tls_link_map_name
private global tls_link_map_start
private global tls_link_map_end
private global tls_module = 0

// @cast of glibc include/link.h gives compile errors compiling module so until resolution:
// some link_map members are in glibc include/link.h but not in /usr/include/link.h
// so use member offsets, e.g. (void*)(&((struct link_map *)0)->l_tls_modid) = 1112
private global l_tls_modid_offset = 1112
private global l_map_start_offset = 848
private global l_map_end_offset = 856
private global l_text_end_offset = 864  

@__private30 function get_thread_context_pointer () %{
  // Get the thread context pointer that points to the tls thread control block
# ifdef __i386
  unsigned long gs;
  rdmsrl(MSR_FS_BASE, gs);
  STAP_RETVALUE = gs;
# elif __x86_64
  unsigned long fs;
  rdmsrl(MSR_FS_BASE, fs);
  STAP_RETVALUE = fs;
# elif __s390x__
// untested
  unsigned long tlsval;
  asm ("ear %0,%%a0" : "=r" (tlsval));
  asm ("sllg %0,%0,32" : "=r" (tlsval));
  asm ("ear %0,%%a1" : "=r" (tlsval));
  # ear %r1,%a0
  # sllg %r1,%r1,32
  # ear %r1,%a1
  STAP_RETVALUE = tlsval;
# elif __aarch64__
// TODO (r18?)
# elif __powerpc64__
// TODO (r13?)
# endif
%}


@__private30 function setup_link_map ()
{
  // Setup the link_map subset : l_name, map_start, map_end
  delete tls_link_map_name
  delete tls_link_map_start
  delete tls_link_map_end
  l_map_count = @var("_rtld_global","/usr/lib64/ld-linux-x86-64.so.2")->_dl_nns
  // TODO Do namespaces need to be supported? assume [0]
  l_map = @var("_rtld_global","/usr/lib64/ld-linux-x86-64.so.2")->_dl_ns[0]->_ns_loaded;
  if (tls_debug > 1)
    println (@var("_rtld_global","/usr/lib64/ld-linux-x86-64.so.2")->_dl_ns[0]->_ns_loaded$);
  l = l_map
  while (l)
    {
     l_name = user_string(@cast(l, "link_map", "<link.h>")->l_name);
     l_addr = user_uint64(@cast(l, "link_map", "<link.h>")->l_addr);
     l_tls_modid = user_int64(l + l_tls_modid_offset)
     l_map_start = user_int64(l + l_map_start_offset)
     l_map_end = user_int64(l + l_map_end_offset)
     l_text_end = user_int64(l + l_text_end_offset)
     for (lni = 0; lni < strlen (l_name); lni++) {
	if (stringat(l_name, lni) == 0x2f)
	   slash = lni
	}
     if (slash > 0)
	 slash += 1;
     if (l_tls_modid == 1)
       l_name = execname();
     if (l_tls_modid != 0)
       {
	 tls_link_map_name[l_tls_modid] = substr (l_name, slash, strlen(l_name)-slash)
	 tls_link_map_start[l_tls_modid] = l_map_start
	 tls_link_map_end[l_tls_modid] = l_map_end
	 if (tls_debug)
	   printf("link_map: %s l_addr=%#lx modid=%d map_start=%#lx map_end=%#lx text_end=%#lx\n", tls_link_map_name[l_tls_modid], l_addr, l_tls_modid, l_map_start, l_map_end, l_text_end);
       }
     l = @cast(l, "link_map", "<link.h>")->l_next;
    }
}


@__private30 function set_tls_module_by_addr ()
{
  // Find the module by matching the probe address from the link_map
  // See glibc td_thr/td_thr_tls_get_addr.c which does something similar
  probe_addr = addr()
  // TODO return probe addr can result in a false positive
  if (isinstr(pp(), ".return"))
      return 0;

  foreach (lm in tls_link_map_name) {
    if (tls_link_map_start[lm] < probe_addr && probe_addr < tls_link_map_end[lm]) 
      {
	if (tls_debug)
	  printf("Address Match: %s map_start=%#lx probe_address=%#lx map_end=%#lx \n",
		 tls_link_map_name[lm], tls_link_map_start[lm], probe_addr,tls_link_map_end[lm])
	return lm;
      }
  }
}


@__private30 function set_tls_module_by_name ()
{
  // Find the module by matching the name from the link_map to the name from the probe
  // This is a backup measure.
  tls_pp = pp()
  probe_addr = addr()
  proc = strpos(tls_pp, "process(\"") + 9;
  for (lpp = proc; lpp > 8 && lpp < strlen (tls_pp); lpp++)
      if (stringat(tls_pp, lpp) == 0x22) {
	  matched_proc = substr(tls_pp, proc, lpp - 9)
	  break;
      }
  
  foreach (lm in tls_link_map_name) {
    if (lm==0) continue;
    // very simple exact match; e.g. fails with libc.so.6 libc-2.31.so
    // TODO Improve match
      if (isinstr(matched_proc, tls_link_map_name[lm])) {
	 if (tls_debug)
	   printf("Name Match: %s map_start=%#lx probe_address=%#lx map_end=%#lx \n",
		 tls_link_map_name[lm], tls_link_map_start[lm], probe_addr,tls_link_map_end[lm])
	  return lm;
      }
  }
}


/**
 * sfunction __push_tls_address - Handle implicit tls variable relocation
 * 
 * Description: Called for DW_OP_GNU_push_tls_address relocation from loc2stap.css::location_context::translate
 */

function __push_tls_address (tls_var_offset:long) 
{
  tcbhead = get_thread_context_pointer ();
  setup_link_map ();
  module = set_tls_module_by_addr ();
  if (module == 0)
    // finding the module by address failed, so try by name
    module = set_tls_module_by_name ();
  if (module) 
    {
      // dtv[-1] is module count
      // dtv[0] is generation count
      // dtv[1] is module[0] info, the main executable
      // dtv[2..n] is module info for dependent shared objects
      dtv$counter = @cast(tcbhead, "tcbhead", "<linux/stp_tls.h>")->dtv[-1]->counter;
      dtv$gen = @cast(tcbhead, "tcbhead", "<linux/stp_tls.h>")->dtv[0]->counter;
      dtv1$pointer$val = @cast(tcbhead, "tcbhead", "<linux/stp_tls.h>")->dtv[module]->pointer->val;
      return dtv1$pointer$val + tls_var_offset;
    }
  else
    return 0;
}
